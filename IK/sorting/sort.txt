- Searching for a value in sorted array is faster than unsorted array.
- Duplicates can be easily found.
- Matching items in 2 or more files.
- To find median and top K values quickly.
- Truncated top of immense sorted list in UI(like Google, FB, amazon). These companies sort items based on relavence and show top 5/10 items. 


For unsorted numbers: mean(averge of numbers) and range(diff of largest and smallest) can be done in single scan.
for sorted numbers : find a specific number, find duplicates, find median, mode can be done in single scan.


- Brute force design:
- example: selection sort.
- Selection sort:
    - find the smallest element in iteration 1 and put at first.
    - find the next smallest element in iteration 2 and put at second. so on.

    Also
    - from the last, find the largest element and swap it with last element.
    - find the next largest element and swap with second last and so on.

- design selection sort:
    def selection_sort(A):
        n = len(A)
        for i in range(n):
            minval = A[i]
            minindex = i
            for j in range(i + 1, n):
                if A[j] < minval:
                    minval = A[j]
                    minindex = j
            swap(A[i], A[minindex])
        return A

Time complexity: O(n ^ 2)
Space complexity: constant


- Efficieny:
    - Time : how long the process runs on CPU. CPU time.
    - Space: how much memory the process takes in RAM. RAM space.

- normal operations like assignment, swap, comparison are done in constant amount of time.
- For asymptotic operations only input size is considered. Language used, hardware used and OS used are ignored.

- Bubble sort:
    - In iteration 1: from the last, compare n and n-1 elements and arrange them in order. Then n-1 and n-2 compare. so on
    so that after iteration 1, smallest value is at 0th index.
    - In iteration 2: from the last, compare n and n-1 so that, second smallest is kept at 1st index.
    - After iteration n: n elements are sorted.

Time complexity: O(n ^ 2)
Space complexity: constant

With selection sort, the time complexity is same for best, average, worst case scenario O(n ^ 2).

Bubble sort is worst than selection sort since in each iteration n comparison, swappings are done. In selection sort, only 1 swap is done
after every iteration.

- design Bubble sort:
    def bubble_sort(A):
        l = len(A)
        for i in range(l):
            for j in range(n - 1, i + 1):
                if A[j] < A[j - 1]:
                    A[j], A[j - 1] = A[j - 1], A[j]
        return A


- For a sorted or reverse sorted array, n(n-1)/2 comparisons are needed in bubble sort.
- 0 swap operations are performed for sorted array using bubble sort.
- n(n-1)/2 swap operations are performed for reverse sorted array using bubble sort.

With bubble sort, the time complexity is same for best, average, worst case scenario O(n ^ 2).


- Insertion sort: It uses decrease-and-conquer algorithm.
In first iteration, we take first element and sort it.
In second iteration, we assign second index element as temp(pivot). Take the second index and compare with pivot. If second is lower than
first, than move first to second and keep pivot to first.
In third iteration, we assign third index element as temp(pivot). we move second index element to right if its greater than
pivot and move first index element to right if its greater than pivot. Accordingly we keep temp in third or second or first position.
and so on.

- Design insertion sort:
    def insertion_sort(A):
        for i in range(len(A)):   # [5, 6, 2, 4]
            pivot = A[i]
            j = i - 1
            while j >= 0 and A[j] > temp:
                A[j+1] = A[j]
                j -= 1
            A[j + 1] = pivot
        return A


Time complexity: Best case scenario: if list is already sorted: O(n). No right shift operations are done.
                 Average case scenario: some elements in list are sorted and some not sorted. O(n ^ 2).
                 Worst case scenario: if list is reverse sorted: O(n ^ 2). All right shift operations are done.

Size and nature(sorted or reverse sorted) of the input determine the complexity.

Bogosort(also called stupid sort) randomly shuffles elements and checks if array is sorted every time until it is sorted.







